# Table of content <!-- no toc -->
- [Architectural designs](#architectural-designs)
  - [Layered architecture](#layered-architecture)
  - [Event-driven architecture](#event-driven-architecture)
  - [Microkernel architecture](#microkernel-architecture)
  - [Microservices architecture](#microservices-architecture)
  - [Space-based architecture](#space-based-architecture)

# Architectural designs

## Layered architecture
- The most common architectural design also called Model-View-Controller (MVC) structure.
- Code is arranged in different layers where data works iteself down from the top layer view, to controller and in the end the model (most of the time where a database resides).
- Most common frameworks out there has had this design in mind when designing the framework (e.g. commonly used Express).
- In a web applications, the top layer (view) usually contains CSS, Javascript and HTML, in the middle, the controller has various rules and methods for transforming the data moving between the view and the model.
- Some advantages to this architecture is the seperate of concern (divide and conquer) aspects meaning each layer can focus solely on its role making it Maintainable, Testable, Easy to assign separate "roles" and Easy to assign separate "roles".
- Some disadvantages to this architecture can be:
  - Source code can become unhandleable if it is unorganized and the developers hasn't created modules with clear roles or relationships.
  - Slow handling, "Sinkhole anti-pattern" meaning code can be devoted to passing data through layers without using any logic.
  - Harder to see the big picture of the whole application (withouth seeing/understand all the layers).
- The architectur is best used:
  - To quickly build a new application.
  - To mirror traditional IT departments and processes.
  - If there are many inexperienced developers on the team.
  - When the application has strict development- and testability standards.

## Event-driven architecture
- Central unit design that accepts all data/input and delegates to seperate modules.
- An example in web development can be a webpage that handles all input (e.g keystrokes, clicks etc) and in turn makes sure that the the right code gets triggered. The architectur is best used for asynchronous systems with asynchronous data flow, User interfaces and when the specific events only interacts with a few of many modules.
- The event-driven architecture pattern consists of two main topologies, the mediator and the broker. The mediator topology is used most commonly when the code need to orchestrated into multiple steps within an event through a central mediator, whereas the broker topology is used when chaining events together without the use of a central mediator.
- The mediator topology is useful for events that have multiple steps and require some level of orchestration to process the event.
- The broker topology differs from the mediator topology in that there is no central event mediator; rather, the message flow is distributed across the event processor components in a chain-like fashion through a lightweight message broker (e.g ActiveMQ, HornetQ, etc).
- It is common to have anywhere from a dozen to several hundred event queues in an event-driven architecture. The pattern does not specify the implementation of the event queue component; it can be a message queue, a web service endpoint, or any combination thereof.
- There are two types of events within this pattern: an initial event and a processing event. The initial event is the original event received by the mediator, whereas the processing events are ones that are generated by the mediator and received by the event-processing components.
- Some advantages to this architecture is:
  - Easily adaptable to complex enviroments.
  - Easily scalable.
  - Easily extendable.
- Some disadvantages to this architecture can be:
  - Complex testing.
  - Difficult error handling.
  - Central unit needs a backup-plan when specific modules fails.
  - Risk of slow down due to message overhead.

## Microkernel architecture
- An architecture containing a core system and plugin modules.
- Application logic is divided between the independent plugin modules and the basic core system, which provides extensibility, flexibility, and isolation of application features and custom processing logic.
- Also commonly refered to as a plug-in architecture.
- Plugin modules are stand-alone independent components that contain specialized processing, additional features, and custom code that is meant to enhance or extend the core system to produce additional business capabilities.
- The core system needs to know about which plug-in modules are available and how to get to them. One common way of implementing this is through some sort of plug-in registry.
- The plug-in modules must remain independent from one another.
- Some advantages to this architecture is:
  - It can be embedded or used as part of another architecture pattern.
  - The microservices architecture pattern provides great support for evolutionary design and incremental development (e.g easily add features without making changes to the core product).
  - The goto architecture for product-based applications where additional features over time will be released and control is desired over which users get which features.
- Some disadvantages to this architecture can be:
  - Due to the the product based implementations most microkernel architecture implementations are implemented as a single unit, making it harder to scale.
  - The microkernel architecture requires thoughtful design and contract governance, making it rather complex to implement.
  - Contract versioning, internal plug-in registries, plug-in granularity, and the wide choices available for plug-in connectivity all contribute to the complexity involved with implementing this pattern

## Microservices architecture
- Common core concepts that apply to the general architecture pattern
  - The notion of separately deployed units.
  - The notion of a service component.
  - It is a distributed architecture, meaning that all the components within the architecture are fully decoupled from one other and accessed through some sort of remote access protocol (e.g., JMS, AMQP, REST, SOAP, RMI, etc.).
- There are literally dozens of ways to implement a microservices architecture pattern, three main topologies stand out as the most common and popular: the API REST-based topology, application REST-based topology, and the centralized messaging topology.
  - The API REST-based topology is useful for websites that expose small, self-contained individual services through some sort of API
  - The application REST-based topology differs from the API REST-based approach in that client requests are received through traditional web-based or fat-client business application screens rather than through a simple API layer.
  - Another common approach within the microservices architecture pattern is the centralized messaging topology. This topology (illustrated in Figure 4-4) is similar to the previous application REST-based topology except that instead of using REST for remote access, this topology uses a lightweight centralized message broker (e.g., ActiveMQ, HornetQ, etc.).
- Some advantages to this architecture is:
    - The deployment characteristics of the microservices pattern rate very high due to the fine-grained and independent nature of the remote services.
    - Due to the separation and isolation of business functionality into independent applications, testing can be scoped, allowing for more targeted testing efforts.
    - Because the application is split into separately deployed units, each service component can be individually scaled, allowing for fine-tuned scaling of the application.
    - Because functionality is isolated into separate and distinct service components, development becomes easier due to the smaller and isolated scope.
- Some disadvantages to this architecture can be:
    - Overall this pattern does not naturally lend itself to high-performance applications due to the distributed nature of the microservices architecture pattern.

## Space-based architecture
- The space-based architecture pattern is specifically designed to address and solve scalability and concurrency issues. It is also a useful architecture pattern for applications that have variable and unpredictable concurrent user volumes.
- This pattern gets its name from the concept of tuple space, the idea of distributed shared memory.
- High scalability is achieved by removing the central database constraint and using replicated in-memory data grids instead. Application data is kept in-memory and replicated among all the active processing units. Processing units can be dynamically started up and shut down as user load increases and decreases, thereby addressing variable scalability. Because there is no central database, the database bottleneck is removed, providing near-infinite scalability within the application.
- There are two primary components within this architecture pattern: a processing unit and virtualized middleware.
  - The processing-unit component contains the application components (or portions of the application components). This includes web-based components as well as backend business logic.
  - The virtualized-middleware component handles housekeeping and communications. The virtualized middleware is essentially the controller for the architecture and manages requests, sessions, data replication, distributed request processing, and process-unit deployment. There are four main architecture components in the virtualized middleware: the messaging grid, the data grid, the processing grid, and the deployment manager.
    - When a request comes into the virtualized-middleware component, the messaging-grid component determines which active processing components are available to receive the request and forwards the request to one of those processing units.
    - The data-grid component is perhaps the most important and crucial component in this pattern. The data grid interacts with the data-replication engine in each processing unit to manage the data replication between processing units when data updates occur.
    - The processing grid is an optional component within the virtualized middleware that manages distributed request processing when there are multiple processing units, each handling a portion of the application. If a request comes in that requires coordination between processing unit types (e.g., an order processing unit and a customer processing unit), it is the processing grid that mediates and orchestrates the request between those two processing units.
    - The deployment-manager component manages the dynamic startup and shutdown of processing units based on load conditions. This component continually monitors response times and user loads, and starts up new processing units when load increases, and shuts down processing units when the load decreases. It is a critical component to achieving variable scalability needs within an application.
- Some advantages to this architecture is:
  - It is a good architecture choice for smaller web-based applications with variable load (e.g., social media sites, bidding and auction sites).
  - Although space-based architectures are generally not decoupled and distributed, they are dynamic, and sophisticated cloud-based tools allow for applications to easily be “pushed” out to servers, simplifying deployment.
  - High performance is achieved through the in-memory data access and caching mechanisms build into this pattern.
  - High scalability come from the fact that there is little or no dependency on a centralized database, therefore essentially removing this limiting bottleneck from the scalability equation.
- Some disadvantages to this architecture can be:
  - The space-based architecture pattern is a complex and expensive pattern to implement.
  - Achieving very high user loads in a test environment is both expensive and time consuming, making it difficult to test the scalability aspects of the application.